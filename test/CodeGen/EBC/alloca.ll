; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=ebc -verify-machineinstrs < %s \
; RUN:  | FileCheck %s -check-prefix=EBC

declare void @notdead(i8*)

; These test must ensure the stack pointer is restored using the frame
; pointer

define void @simple_alloca(i64 %n) nounwind {
; EBC-LABEL: simple_alloca:
; EBC:       ; %bb.0:
; EBC-NEXT:    push64 r1
; EBC-NEXT:    push64 r2
; EBC-NEXT:    movqw r6, r0 (0,0)
; EBC-NEXT:    movqw r7, r6 (0,24)
; EBC-NEXT:    movqq r7, @r7
; EBC-NEXT:    moviww r1, -8
; EBC-NEXT:    movqq r2, r1
; EBC-NEXT:    and64 r2, r7 7
; EBC-NEXT:    movqq r7, r0
; EBC-NEXT:    sub64 r7, r2
; EBC-NEXT:    movqq r0, r7
; EBC-NEXT:    movqq r2, r0
; EBC-NEXT:    add64 r2, r1
; EBC-NEXT:    movqq @r2, r7
; EBC-NEXT:    call64 notdead
; EBC-NEXT:    movqw r0, r6 (0,0)
; EBC-NEXT:    pop64 r2
; EBC-NEXT:    pop64 r1
; EBC-NEXT:    ret
  %1 = alloca i8, i64 %n
  call void @notdead(i8* %1)
  ret void
}

declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8*)

define void @scoped_alloca(i64 %n) nounwind {
; EBC-LABEL: scoped_alloca:
; EBC:       ; %bb.0:
; EBC-NEXT:    push64 r1
; EBC-NEXT:    push64 r2
; EBC-NEXT:    push64 r3
; EBC-NEXT:    movqw r6, r0 (0,0)
; EBC-NEXT:    movqw r7, r6 (0,32)
; EBC-NEXT:    movqq r7, @r7
; EBC-NEXT:    moviww r1, -8
; EBC-NEXT:    movqq r2, r1
; EBC-NEXT:    and64 r2, r7 7
; EBC-NEXT:    movqq r3, r0
; EBC-NEXT:    movqq r7, r0
; EBC-NEXT:    sub64 r7, r2
; EBC-NEXT:    movqq r0, r7
; EBC-NEXT:    movqq r2, r0
; EBC-NEXT:    add64 r2, r1
; EBC-NEXT:    movqq @r2, r7
; EBC-NEXT:    call64 notdead
; EBC-NEXT:    movqq r0, r3
; EBC-NEXT:    movqw r0, r6 (0,0)
; EBC-NEXT:    pop64 r3
; EBC-NEXT:    pop64 r2
; EBC-NEXT:    pop64 r1
; EBC-NEXT:    ret
  %sp = call i8* @llvm.stacksave()
  %addr = alloca i8, i64 %n
  call void @notdead(i8* %addr)
  call void @llvm.stackrestore(i8* %sp)
  ret void
}
