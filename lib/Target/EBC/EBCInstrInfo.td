//===-- EBCInstrInfo.td - Target Description for EBC ---*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file describes the EBC instructions in TableGen format.
//
//===----------------------------------------------------------------------===//

include "EBCInstrFormats.td"

//===----------------------------------------------------------------------===//
// Operand and SDNode transformation definitions.
//===----------------------------------------------------------------------===//

class BreakCodeAsmOperand<int width> : AsmOperandClass {
  let Name = "BreakCode" # width;
  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);
}

class ImmAsmOperand<int width> : AsmOperandClass {
  let Name = "Imm" # width;
  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);
}

class IdxNAsmOperand<int width> : AsmOperandClass {
  let Name = "IdxN" # width;
  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);
}

class IdxCAsmOperand<int width> : AsmOperandClass {
  let Name = "IdxC" # width;
  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);
}

let OperandNamespace = "EBC" in {

let OperandType = "OPERAND_BREAKCODE" in
def breakcode : Operand<i8> {
  let ParserMatchClass = BreakCodeAsmOperand<8>;
}

let OperandType = "OPERAND_IMM8" in
def imm8 : Operand<i8> {
  let ParserMatchClass = ImmAsmOperand<8>;
}

let OperandType = "OPERAND_IMM16" in
def imm16 : Operand<i16> {
  let ParserMatchClass = ImmAsmOperand<16>;
}

let OperandType = "OPERAND_IMM32" in
def imm32 : Operand<i32> {
  let ParserMatchClass = ImmAsmOperand<32>;
}

let OperandType = "OPERAND_IMM64" in
def imm64 : Operand<i64> {
  let ParserMatchClass = ImmAsmOperand<64>;
}

let OperandType = "OPERAND_IDXN16" in
def idxn16 : Operand<i16> {
  let ParserMatchClass = IdxNAsmOperand<16>;
}

let OperandType = "OPERAND_IDXC16" in
def idxc16 : Operand<i16> {
  let ParserMatchClass = IdxCAsmOperand<16>;
}

let OperandType = "OPERAND_IDXN32" in
def idxn32 : Operand<i32> {
  let ParserMatchClass = IdxNAsmOperand<32>;
}

let OperandType = "OPERAND_IDXC32" in
def idxc32 : Operand<i32> {
  let ParserMatchClass = IdxCAsmOperand<32>;
}

let OperandType = "OPERAND_IDXN64" in
def idxn64 : Operand<i64> {
  let ParserMatchClass = IdxNAsmOperand<64>;
}

let OperandType = "OPERAND_IDXC64" in
def idxc64 : Operand<i64> {
  let ParserMatchClass = IdxCAsmOperand<64>;
}

} // OperandNamespace = "EBC"

//===----------------------------------------------------------------------===//
// Instruction Class Templates
//===----------------------------------------------------------------------===//

class EBCCALL<bits<6> opcode,
                bit hasImmIdx, bit is64Bit, bit isNative,
                bit isRel, bit Op1Indirect,
                dag outs, dag ins, dag immins, dag idxins,
                string op1str, string immstr, string idxstr>
      : EBCInst1Op<opcode, hasImmIdx, is64Bit, Op1Indirect, outs,
          !cond(!eq(hasImmIdx, 0) : ins,
                !eq(!and(hasImmIdx, Op1Indirect), 0) : !con(ins, immins),
                !eq(!and(hasImmIdx, Op1Indirect), 1) : !con(ins, idxins)),
          "call"
        # !if(is64Bit, "64", "32")
        # !if(isNative, "ex", "")
        # !if(isRel, "", "a"),
          !if(Op1Indirect, "@", "")
        # !if(is64Bit, "", op1str)
        # !if(hasImmIdx, " ", "")
        # !cond(!eq(hasImmIdx, 0) : "",
                !eq(!and(hasImmIdx, Op1Indirect), 0) : immstr,
                !eq(!and(hasImmIdx, Op1Indirect), 1) : idxstr)> {
  let CodeSize = !cond(!and(!eq(is64Bit, 0), !eq(hasImmIdx, 0)) : 2,
                   !and(!eq(is64Bit, 0), !eq(hasImmIdx, 1)) : 6,
                   !eq(is64Bit, 1) : 10);
  let mayLoad = !if(!or(Op1Indirect, is64Bit), 1, 0);
  let Inst{13} = isNative;
  let Inst{12} = isRel;
  let TSFlags{1-0} = 0b01;
  let TSFlags{2} = !if(is64Bit, 1, 0);
  let TSFlags{3} = !if(isNative, 1, 0);
  let TSFlags{4} = !if(isRel, 1, 0);
  let TSFlags{5} = !if(!and(hasImmIdx, !eq(Op1Indirect, 0)), 1, 0);
}

class EBCJMP<bits<6> opcode,
                bit hasImmIdx, bit is64Bit, bit isCond,
                bit isCS, bit isRel, bit Op1Indirect,
                dag outs, dag ins, dag immins, dag idxins,
                string op1str, string immstr, string idxstr>
      : EBCInst1Op<opcode, hasImmIdx, is64Bit, Op1Indirect, outs,
          !cond(!eq(hasImmIdx, 0) : ins,
                !eq(!and(hasImmIdx, Op1Indirect), 0) : !con(ins, immins),
                !eq(!and(hasImmIdx, Op1Indirect), 1) : !con(ins, idxins)),
          "jmp"
        # !if(is64Bit, "64", "32")
        # !cond(!eq(isCond, 0) : "",
                !and(isCond, !eq(isCS, 0)) : "cc",
                !and(isCond, isCS) : "cs")
        # !if(isRel, "", "a"),
          !if(Op1Indirect, "@", "")
        # !if(is64Bit, "", op1str)
        # !if(hasImmIdx, " ", "")
        # !cond(!eq(hasImmIdx, 0) : "",
                !eq(!and(hasImmIdx, Op1Indirect), 0) : immstr,
                !eq(!and(hasImmIdx, Op1Indirect), 1) : idxstr)> {
  let CodeSize = !cond(!and(!eq(is64Bit, 0), !eq(hasImmIdx, 0)) : 2,
                   !and(!eq(is64Bit, 0), !eq(hasImmIdx, 1)) : 6,
                   !eq(is64Bit, 1) : 10);
  let mayLoad = !if(!and(Op1Indirect, !eq(hasImmIdx, 0)), 1, 0);
  let Inst{15} = isCond;
  let Inst{14} = isCS;
  let Inst{12} = isRel;
  let TSFlags{1-0} = 0b10;
  let TSFlags{2} = !if(is64Bit, 1, 0);
  let TSFlags{3} = 0;
  let TSFlags{4} = !if(isRel, 1, 0);
  let TSFlags{5} = !if(!and(hasImmIdx, !eq(Op1Indirect, 0)), 1, 0);
}

class EBCJMP8<bits<6> opcode, bit isCond, bit isCS,
                dag outs, dag ins, string immstr>
        : EBCInst8<opcode, outs, ins,
            "jmp8"
          # !cond(!eq(isCond, 0) : "",
                  !and(isCond, !eq(isCS, 0)) : "cc",
                  !and(isCond, isCS) : "cs"),
            immstr, []> {
  let CodeSize = 2;
  let Inst{7} = isCond;
  let Inst{6} = isCS;
  let TSFlags{1-0} = 0b11;
  let TSFlags{2} = 0;
  let TSFlags{3} = 0;
  let TSFlags{4} = 0;
  let TSFlags{5} = 0;
}

class EBCPUSHPOP<bits<6> opcode, bit hasImmIdx, bit is64Bit, bit Op1Indirect,
                dag outs, dag ins, dag immins, dag idxins,
                string opcodestr, string op1str, string immstr, string idxstr>
      : EBCInst1Op<opcode, hasImmIdx, is64Bit, Op1Indirect, outs,
          !cond(!eq(hasImmIdx, 0) : ins,
                !eq(!and(hasImmIdx, Op1Indirect), 0) : !con(ins, immins),
                !eq(!and(hasImmIdx, Op1Indirect), 1) : !con(ins, idxins)),
          opcodestr
        # !if(is64Bit, "64", "32"),
          !if(Op1Indirect, "@", "")
        # op1str
        # !if(hasImmIdx, " ", "")
        # !cond(!eq(hasImmIdx, 0) : "",
                !eq(!and(hasImmIdx, Op1Indirect), 0) : immstr,
                !eq(!and(hasImmIdx, Op1Indirect), 1) : idxstr)> {
  let CodeSize = !if(hasImmIdx, 4, 2);
  let mayLoad = !if(!and(Op1Indirect, hasImmIdx), 1, 0);
}

class EBCPUSHnPOPn<bits<6> opcode, bit hasImmIdx, bit Op1Indirect,
                dag outs, dag ins, dag immins, dag idxins,
                string opcodestr, string op1str, string immstr, string idxstr>
      : EBCInst1Op<opcode, hasImmIdx, 0, Op1Indirect, outs,
          !cond(!eq(hasImmIdx, 0) : ins,
                !eq(!and(hasImmIdx, Op1Indirect), 0) : !con(ins, immins),
                !eq(!and(hasImmIdx, Op1Indirect), 1) : !con(ins, idxins)),
          opcodestr,
          !if(Op1Indirect, "@", "")
        # op1str
        # !if(hasImmIdx, " ", "")
        # !cond(!eq(hasImmIdx, 0) : "",
                !eq(!and(hasImmIdx, Op1Indirect), 0) : immstr,
                !eq(!and(hasImmIdx, Op1Indirect), 1) : idxstr)> {
  let CodeSize = !if(hasImmIdx, 4, 2);
  let mayLoad = !if(!and(Op1Indirect, hasImmIdx), 1, 0);
}

class EBCALUBase<bits<6> opcode, bit hasImmIdx, bit is64Bit,
          bit Op1Indirect, bit Op2Indirect,
          dag outs, dag ins, dag immins, dag idxins,
          string opcodestr, string op1str, string op2str,
          string immstr, string idxstr>
      : EBCInst2Op<opcode, hasImmIdx, is64Bit, Op1Indirect, Op2Indirect, outs,
        !cond(!eq(hasImmIdx, 0) : ins,
              !eq(!and(hasImmIdx, Op2Indirect), 0) : !con(ins, immins),
              !eq(!and(hasImmIdx, Op2Indirect), 1) : !con(ins, idxins)),
        opcodestr # !if(is64Bit, "64", "32"),
        !if(Op1Indirect, "@", "") # op1str # ", "
      # !if(Op2Indirect, "@", "") # op2str # !if(hasImmIdx, " ", "")
      # !cond(!eq(hasImmIdx, 0) : "",
              !eq(!and(hasImmIdx, Op2Indirect), 0) : immstr,
              !eq(!and(hasImmIdx, Op2Indirect), 1) : idxstr)> {
  bits<3> dst;
  let CodeSize = !if(hasImmIdx, 4, 2);
  let mayLoad = !if(Op2Indirect, 1, 0);
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCCMPBase<bits<6> opcode, bit hasImmIdx, bit is64Bit, bit Op2Indirect,
          dag outs, dag ins, dag immins, dag idxins,
          string opsuffix, string op1str, string op2str,
          string immstr, string idxstr>
      : EBCInst2Op<opcode, hasImmIdx, is64Bit, 0, Op2Indirect, outs,
          !cond(!eq(hasImmIdx, 0) : ins,
                !eq(!and(hasImmIdx, Op2Indirect), 0) : !con(ins, immins),
                !eq(!and(hasImmIdx, Op2Indirect), 1) : !con(ins, idxins)),
          "cmp" # !if(is64Bit, "64", "32") # opsuffix,
          op1str # ", " # !if(Op2Indirect, "@", "") # op2str
        # !cond(!eq(hasImmIdx, 0) : "",
                !and(!eq(hasImmIdx, 1), !eq(Op2Indirect, 0)) : " " # immstr,
                !and(!eq(hasImmIdx, 1), !eq(Op2Indirect, 1)) : " " # idxstr)> {
  let CodeSize = !if(hasImmIdx, 4, 2);
  let mayLoad = !if(Op2Indirect, 1, 0);
}

class EBCCMPIBase<bits<6> opcode,
          bit hasOp1Idx, bit is64Bit, bit immlen, bit Op1Indirect,
          dag outs, dag ins, dag immins, dag idxins,
          string opsuffix, string op1str, string immstr, string idxstr>
      : EBCInst16<opcode, outs,
          !if(hasOp1Idx, !con(ins, immins, idxins), !con(ins, immins)),
          "cmpi" # !if(is64Bit, "64", "32") # !if(immlen, "d", "w")# opsuffix,
          !if(Op1Indirect, "@", "") # op1str
        # !if(hasOp1Idx, " " # idxstr, "") # ", " # immstr, []> {
  bits<3> op1;

  let Inst{7} = immlen;
  let Inst{6} = is64Bit;
  let Inst{12} = hasOp1Idx;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !cond(!and(!eq(hasOp1Idx, 0), !eq(immlen, 0)) : 4,
                   !and(!eq(hasOp1Idx, 0), !eq(immlen, 1)) : 6,
                   !and(!eq(hasOp1Idx, 1), !eq(immlen, 0)) : 6,
                   !and(!eq(hasOp1Idx, 1), !eq(immlen, 1)) : 8);
  let mayLoad = !if(Op1Indirect, 1, 0);
}

class EBCMOVBase<bits<6> opcode, bits<2> idxlen, bits<2> movlen,
            bit hasOp1Idx, bit hasOp2Idx, bit Op1Indirect, bit Op2Indirect,
            dag outs, dag ins, dag op1idxins, dag op2idxins,
            string op1str, string op2str, string op1idxstr, string op2idxstr>
      : EBCInst<opcode, outs,
          !cond(!and(!eq(hasOp1Idx, 0), !eq(hasOp2Idx, 0)) : ins,
                !and(hasOp1Idx, !eq(hasOp2Idx, 0)) : !con(ins, op1idxins),
                !and(!eq(hasOp1Idx, 0), hasOp2Idx) : !con(ins, op2idxins),
                !and(hasOp1Idx, hasOp2Idx) : !con(ins, op1idxins, op2idxins)),
          "mov"
        # !cond(!eq(movlen, 0b00) : "b", !eq(movlen, 0b01) : "w",
                !eq(movlen, 0b10) : "d", !eq(movlen, 0b11) : "q")
        # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d",
                !eq(idxlen, 0b11) : "q"),
          !if(Op1Indirect, "@", "") # op1str
        # !if(hasOp1Idx, " ", "") # !if(hasOp1Idx, op1idxstr, "")
        # ", "
        # !if(Op2Indirect, "@", "") # op2str
        # !if(hasOp2Idx, " ", "") # !if(hasOp2Idx, op2idxstr, ""), []> {
  field bits<16> Inst;
  field bits<16> SoftFail = 0;
  bits<3> op1;
  bits<3> op2;

  let Size = 2;
  let Opcode = !add(opcode, !shl(idxlen, 2), movlen);

  let Inst{7} = hasOp1Idx;
  let Inst{6} = hasOp2Idx;
  let Inst{5-0} = Opcode;
  let Inst{15} = Op2Indirect;
  let Inst{14-12} = op2;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, !shl(1, idxlen), 0),
                     !if(hasOp2Idx, !shl(1, idxlen), 0));
  let mayLoad = !if(Op2Indirect, 1, 0);
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCMOVIBase<bits<6> opcode, bits<2> immlen, bits<2> movlen,
            bit hasOp1Idx, bit Op1Indirect,
            dag outs, dag ins, dag op1idxins, dag immins,
            string op1str, string immstr, string op1idxstr>
      : EBCInst16<opcode, outs,
            !cond(!eq(hasOp1Idx, 0) : !con(ins, immins),
                  !eq(hasOp1Idx, 1) : !con(ins, immins, op1idxins)),
            "movi"
          # !cond(!eq(movlen, 0b00) : "b", !eq(movlen, 0b01) : "w",
                  !eq(movlen, 0b10) : "d", !eq(movlen, 0b11) : "q")
          # !cond(!eq(immlen, 0b01) : "w",
                  !eq(immlen, 0b10) : "d", !eq(immlen, 0b11) : "q"),
            !if(Op1Indirect, "@", "") # op1str
          # !if(hasOp1Idx, " " # op1idxstr, "") # ", " # immstr, []> {
  bits<3> op1;

  let Inst{7-6} = immlen;
  let Inst{14} = hasOp1Idx;
  let Inst{13-12} = movlen;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, 2, 0), !shl(1, immlen));
  let mayLoad = 0;
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCMOVRELBase<bits<6> opcode, bits<2> immlen,
              bit hasOp1Idx, bit Op1Indirect,
              dag outs, dag ins, dag op1idxins, dag immins,
              string op1str, string immstr, string op1idxstr>
      : EBCInst16<opcode, outs,
              !cond(!eq(hasOp1Idx, 0) : !con(ins, immins),
                    !eq(hasOp1Idx, 1) : !con(ins, immins, op1idxins)),
              "movrel"
            # !cond(!eq(immlen, 0b01) : "w", !eq(immlen, 0b10) : "d",
                    !eq(immlen, 0b11) : "q"),
              !if(Op1Indirect, "@", "") # op1str
            # !if(hasOp1Idx, " " # op1idxstr, "") # ", " # immstr, []> {
  bits<3> op1;

  let Inst{7-6} = immlen;
  let Inst{14} = hasOp1Idx;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, 2, 0), !shl(1, immlen));
  let mayLoad = 0;
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCMOVnBase<bits<6> opcode, bits<2> idxlen,
            bit hasOp1Idx, bit hasOp2Idx,
            bit Op1Indirect, bit Op2Indirect,
            dag outs, dag ins, dag op1idxins, dag op2idxins,
            string op1str, string op2str,
            string op1idxstr, string op2idxstr>
      : EBCInst16<opcode, outs,
            !cond(!and(!eq(hasOp1Idx, 0), !eq(hasOp2Idx, 0)) : ins,
                  !and(hasOp1Idx, !eq(hasOp2Idx, 0)) : !con(ins, op1idxins),
                  !and(!eq(hasOp1Idx, 0), hasOp2Idx) : !con(ins, op2idxins),
                  !and(hasOp1Idx, hasOp2Idx) : !con(ins, op1idxins, op2idxins)),
            "movn" # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d"),
            !if(Op1Indirect, "@", "") # op1str
          # !if(hasOp1Idx, " " # op1idxstr, "") # ", "
          # !if(Op2Indirect, "@", "") # op2str
          # !if(hasOp2Idx, " " # op2idxstr, ""), []> {
  bits<3> op1;
  bits<3> op2;

  let Inst{7} = hasOp1Idx;
  let Inst{6} = hasOp2Idx;
  let Inst{15} = Op2Indirect;
  let Inst{14-12} = op2;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, !shl(1, idxlen), 0), !if(hasOp2Idx, !shl(1, idxlen), 0));
  let mayLoad = !if(Op2Indirect, 1, 0);
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCMOVsnBase<bits<6> opcode, bits<2> idxlen,
            bit hasOp1Idx, bit hasOp2Idx,
            bit Op1Indirect, bit Op2Indirect,
            dag outs, dag ins, dag op1idxins, dag op2idxins, dag op2immins,
            string op1str, string op2str,
            string op1idxstr, string op2idxstr, string op2immstr>
      : EBCInst16<opcode, outs,
            !cond(!and(!eq(hasOp1Idx, 0), !eq(hasOp2Idx, 0)) : ins,
                  !and(hasOp1Idx, !eq(hasOp2Idx, 0))
                  : !con(ins, op1idxins),
                  !and(!eq(hasOp1Idx, 0), hasOp2Idx, !eq(Op2Indirect, 0))
                  : !con(ins, op2immins),
                  !and(!eq(hasOp1Idx, 0), hasOp2Idx, Op2Indirect)
                  : !con(ins, op2idxins),
                  !and(hasOp1Idx, hasOp2Idx, !eq(Op2Indirect, 0))
                  : !con(ins, op1idxins, op2immins),
                  !and(hasOp1Idx, hasOp2Idx, Op2Indirect)
                  : !con(ins, op1idxins, op2idxins)),
            "movsn" # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d"),
            !if(Op1Indirect, "@", "") # op1str
          # !if(hasOp1Idx, " " # op1idxstr, "") # ", "
          # !if(Op2Indirect, "@", "") # op2str
          # !cond(!eq(hasOp2Idx, 0) : "",
                  !and(hasOp2Idx, !eq(Op2Indirect, 0)) : " " # op2immstr,
                  !and(hasOp2Idx, Op2Indirect) : " " # op2idxstr), []> {
  bits<3> op1;
  bits<3> op2;

  let Inst{7} = hasOp1Idx;
  let Inst{6} = hasOp2Idx;
  let Inst{15} = Op2Indirect;
  let Inst{14-12} = op2;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, !shl(1, idxlen), 0), !if(hasOp2Idx, !shl(1, idxlen), 0));
  let mayLoad = !if(Op2Indirect, 1, 0);
  let mayStore = !if(Op1Indirect, 1, 0);
}

class EBCMOVInBase<bits<6> opcode, bits<2> idxlen,
            bit hasOp1Idx, bit Op1Indirect,
            dag outs, dag ins, dag op1idxins, dag op2idxins,
            string op1str, string op1idxstr, string op2idxstr>
      : EBCInst16<opcode, outs,
            !cond(!eq(hasOp1Idx, 0) : !con(ins, op2idxins),
                  !eq(hasOp1Idx, 1) : !con(ins, op1idxins, op2idxins)),
            "movin"
          # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d",
                  !eq(idxlen, 0b11) : "q"),
            !if(Op1Indirect, "@", "") # op1str
          # !if(hasOp1Idx, " " # op1idxstr, "") # ", " # op2idxstr, []> {
  bits<3> op1;

  let Inst{7-6} = idxlen;
  let Inst{14} = hasOp1Idx;
  let Inst{11} = Op1Indirect;
  let Inst{10-8} = op1;

  let CodeSize = !add(2, !if(hasOp1Idx, 2, 0), !shl(1, idxlen));
  let mayLoad = 0;
  let mayStore = !if(Op1Indirect, 1, 0);
}

multiclass EBCALU<bits<6> opcode, string opcodestr> {
  foreach hasImmIdx = [0b0, 0b1] in {
    foreach is64Bit = [0b0, 0b1] in {
      foreach Op1Indirect = [0b0, 0b1] in {
        foreach Op2Indirect = [0b0, 0b1] in
        def !if(is64Bit, "64", "32")
          # !if(Op1Indirect, "Op1I", "Op1D")
          # !if(Op2Indirect, "Op2I", "Op2D")
          # !cond(!eq(hasImmIdx, 0) : "",
                  !eq(!and(hasImmIdx, Op2Indirect), 0) : "Imm",
                  !eq(!and(hasImmIdx, Op2Indirect), 1) : "Idx")
          : EBCALUBase<opcode, hasImmIdx, is64Bit, Op1Indirect, Op2Indirect,
            (outs GPR:$dst), (ins GPR:$op1, GPR:$op2),
            (ins imm16:$imm), (ins idxn16:$idxn, idxc16:$idxc),
            opcodestr, "$op1", "$op2", "$imm", "(${idxn},${idxc})">;
      }
    }
  }
}

multiclass EBCCMP<bits<6> opcode, string opsuffix> {
  foreach hasImmIdx = [0b0, 0b1] in {
    foreach is64Bit = [0b0, 0b1] in {
      foreach Op2Indirect = [0b0, 0b1] in
      def !if(is64Bit, "64", "32")
        # !if(Op2Indirect, "Op2I", "Op2D")
        # !if(hasImmIdx, !if(Op2Indirect, "Idx", "Imm"), "")
        : EBCCMPBase<opcode, hasImmIdx, is64Bit, Op2Indirect,
          (outs), (ins GPR:$op1, GPR:$op2),
          (ins imm16:$imm), (ins idxn16:$idxn, idxc16:$idxc),
          opsuffix, "$op1", "$op2", "$imm", "(${idxn},${idxc})">;
    }
  }
}

multiclass EBCCMPI<bits<6> opcode, string opsuffix> {
  foreach is64Bit = [0b0, 0b1] in {
    foreach immlen = [0b0, 0b1] in {
      foreach Op1Indirect = [0b0, 0b1] in {
        foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in
        def !if(is64Bit, "64", "32")
          # !if(immlen, "d", "w")
          # !if(Op1Indirect, "Op1I", "Op1D")
          # !if(hasOp1Idx, "Idx", "")
          : EBCCMPIBase<opcode, hasOp1Idx, is64Bit, immlen, Op1Indirect,
            (outs), (ins GPR:$op1),
            !cond(!eq(immlen, 0) : (ins imm16:$imm),
                  !eq(immlen, 1) : (ins imm32:$imm)),
            (ins idxn16:$idxn, idxc16:$idxc),
            opsuffix, "$op1", "$imm", "(${idxn},${idxc})">;
      }
    }
  }
}

multiclass EBCMOV<bits<6> opcode, bits<2> idxlen, bits<2> movlen> {
  foreach Op1Indirect = [0b0, 0b1] in {
    foreach Op2Indirect = [0b0, 0b1] in {
      foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in {
        foreach hasOp2Idx = [0b0, 0b1] in
        def !cond(!eq(movlen, 0b00) : "b", !eq(movlen, 0b01) : "w",
                  !eq(movlen, 0b10) : "d", !eq(movlen, 0b11) : "q")
          # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d",
                  !eq(idxlen, 0b11) : "q")
          # !if(Op1Indirect, "Op1I", "Op1D") # !if(hasOp1Idx, "Idx", "")
          # !if(Op2Indirect, "Op2I", "Op2D") # !if(hasOp2Idx, "Idx", "")
          : EBCMOVBase<opcode, idxlen, movlen,
            hasOp1Idx, hasOp2Idx, Op1Indirect, Op2Indirect,
            (outs GPR:$op1), (ins GPR:$op2),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op1idxn, idxc16:$op1idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op1idxn, idxc32:$op1idxc),
                  !eq(idxlen, 0b11) : (ins idxn64:$op1idxn, idxc64:$op1idxc)),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op2idxn, idxc16:$op2idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op2idxn, idxc32:$op2idxc),
                  !eq(idxlen, 0b11) : (ins idxn64:$op2idxn, idxc64:$op2idxc)),
            "$op1", "$op2",
            "(${op1idxn},${op1idxc})", "(${op2idxn},${op2idxc})">;
      }
    }
  }
}

//===----------------------------------------------------------------------===//
// Instructions
//===----------------------------------------------------------------------===//

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
let isTrap = 1 in
def BREAK : EBCInst8<0b000000, (outs), (ins breakcode:$code),
                "break", "$code", []>;

let isReturn = 1 in
def RET : EBCInst16<0b000100, (outs), (ins), "ret", "", []>;

def LOADSP : EBCInst2Op<0b101001, 0, 0, 0, 0, (outs FR:$op1), (ins GPR:$op2),
                "loadsp", "$op1, $op2">;

def STORESP : EBCInst2Op<0b101010, 0, 0, 0, 0, (outs GPR:$op1), (ins DR:$op2),
                "storesp", "$op1, $op2">;
}

let hasSideEffects = 0, mayStore = 0 in {
foreach hasImmIdx = [0b0, 0b1] in {
  foreach isNative = [0b0, 0b1] in {
    foreach isRel = [0b0, 0b1] in {
      foreach Op1Indirect = [0b0, 0b1] in
        def "CALL32"
          # !if(Op1Indirect, "Op1I", "Op1D") # !if(isNative, "Native", "EBC")
          # !if(isRel, "Rel", "Abs")
          # !cond(!eq(hasImmIdx, 0) : "",
                  !eq(!and(hasImmIdx, Op1Indirect), 0) : "Imm",
                  !eq(!and(hasImmIdx, Op1Indirect), 1) : "Idx")
            : EBCCALL<0b000011,
                  hasImmIdx, 0, isNative, isRel, Op1Indirect,
                  (outs), (ins GPR:$op1),
                  (ins imm32:$imm), (ins idxn32:$idxn, idxc32:$idxc),
                  "$op1", "$imm", "(${idxn},${idxc})">;
    }
  }
}
foreach isNative = [0b0, 0b1] in {
  foreach isRel = [0b0, 0b1] in
  def "CALL64"
    # !if(isNative, "Native", "EBC")
    # !if(isRel, "Rel", "Abs")
    # "Imm"
      : EBCCALL<0b000011, 1, 1, isNative, isRel, 0,
                  (outs), (ins), (ins imm64:$imm), (ins), "", "$imm", "">;
}
} // hasSideEffects = 0, mayStore = 0

let hasSideEffects = 0, mayStore = 0 in {
foreach Op1Indirect = [0b0, 0b1] in {
  foreach hasImmIdx = [0b0, 0b1] in {
    foreach isCond = [0b0, 0b1] in {
      foreach isCS = !if(isCond, [0b0, 0b1], [0b0]) in {
        foreach isRel = [0b0, 0b1] in
        def "JMP32"
          # !cond(!eq(isCond, 0) : "Uncond",
                  !and(isCond, !eq(isCS, 0)) : "CC",
                  !and(isCond, !eq(isCS, 1)) : "CS")
          # !if(isRel, "Rel", "Abs")
          # !if(Op1Indirect, "Op1I", "Op1D")
          # !if(hasImmIdx, !if(Op1Indirect, "Idx", "Imm"), "")
            : EBCJMP<0b000001, hasImmIdx, 0, isCond, isCS, isRel, Op1Indirect,
                    (outs), (ins GPR:$op1), (ins imm32:$imm),
                    (ins idxn32:$idxn, idxc32:$idxc),
                    "$op1", "$imm", "(${idxn},${idxc})">;
      }
    }
  }
}
foreach isCond = [0b0, 0b1] in {
  foreach isCS = !if(isCond, [0b0, 0b1], [0b0]) in {
    foreach isRel = [0b0, 0b1] in
    def "JMP64"
      # !cond(!eq(isCond, 0) : "Uncond",
              !and(isCond, !eq(isCS, 0)) : "CC",
              !and(isCond, !eq(isCS, 1)) : "CS")
      # !if(isRel, "Rel", "Abs")
      # "Imm"
        : EBCJMP<0b000001, 1, 1, isCond, isCS, isRel, 0,
                (outs), (ins), (ins imm64:$imm), (ins),
                "", "$imm", "">;
  }
}
} // hasSideEffects = 0, mayStore = 0

let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
foreach isCond = [0b0, 0b1] in {
  foreach isCS = !if(isCond, [0b0, 0b1], [0b0]) in
  def "JMP8"
    # !cond(!eq(isCond, 0) : "Uncond",
            !and(isCond, !eq(isCS, 0)) : "CC",
            !and(isCond, !eq(isCS, 1)) : "CS")
      : EBCJMP8<0b000010, isCond, isCS, (outs), (ins imm8:$imm), "$imm">;
}
} // hasSideEffects = 0, mayLoad = 0, mayStore = 0

let hasSideEffects = 0, mayStore = 0 in {
foreach hasImmIdx = [0b0, 0b1] in {
  foreach is64Bit = [0b0, 0b1] in {
    foreach Op1Indirect = [0b0, 0b1] in
    def "POP"
      # !if(is64Bit, "64", "32") 
      # !if(Op1Indirect, "Op1I", "Op1D")
      # !cond(!eq(hasImmIdx, 0) : "",
              !and(hasImmIdx, !eq(Op1Indirect, 0)) : "Imm",
              !and(hasImmIdx, !eq(Op1Indirect, 1)) : "Idx")
        : EBCPUSHPOP<0b101100, hasImmIdx, is64Bit, Op1Indirect,
              (outs GPR:$op1), (ins), (ins imm16:$imm),
              (ins idxn16:$idxn, idxc16:$idxc),
              "pop", "$op1", "$imm", "(${idxn},${idxc})">;
  }
}
} // hasSideEffects = 0, mayStore = 0

let hasSideEffects = 0, mayStore = 1 in {
foreach hasImmIdx = [0b0, 0b1] in {
  foreach is64Bit = [0b0, 0b1] in {
    foreach Op1Indirect = [0b0, 0b1] in
    def "PUSH"
      # !if(is64Bit, "64", "32") 
      # !if(Op1Indirect, "Op1I", "Op1D")
      # !cond(!eq(hasImmIdx, 0) : "",
              !and(hasImmIdx, !eq(Op1Indirect, 0)) : "Imm",
              !and(hasImmIdx, !eq(Op1Indirect, 1)) : "Idx")
        : EBCPUSHPOP<0b101011, hasImmIdx, is64Bit, Op1Indirect,
              (outs), (ins GPR:$op1), (ins imm16:$imm),
              (ins idxn16:$idxn, idxc16:$idxc),
              "push", "$op1", "$imm", "(${idxn},${idxc})">;
  }
}
} // hasSideEffects = 0, mayStore = 1

let hasSideEffects = 0, mayStore = 0 in {
foreach hasImmIdx = [0b0, 0b1] in {
  foreach Op1Indirect = [0b0, 0b1] in
  def "POPn"
    # !if(Op1Indirect, "Op1I", "Op1D")
    # !cond(!eq(hasImmIdx, 0) : "",
            !and(hasImmIdx, !eq(Op1Indirect, 0)) : "Imm",
            !and(hasImmIdx, !eq(Op1Indirect, 1)) : "Idx")
        : EBCPUSHnPOPn<0b110110, hasImmIdx, Op1Indirect,
            (outs GPR:$op1), (ins), (ins imm16:$imm),
            (ins idxn16:$idxn, idxc16:$idxc),
            "popn", "$op1", "$imm", "(${idxn},${idxc})">;
}
} // hasSideEffects = 0, mayStore = 0

let hasSideEffects = 0, mayStore = 1 in {
foreach hasImmIdx = [0b0, 0b1] in {
  foreach Op1Indirect = [0b0, 0b1] in
  def "PUSHn"
    # !if(Op1Indirect, "Op1I", "Op1D")
    # !cond(!eq(hasImmIdx, 0) : "",
            !and(hasImmIdx, !eq(Op1Indirect, 0)) : "Imm",
            !and(hasImmIdx, !eq(Op1Indirect, 1)) : "Idx")
        : EBCPUSHnPOPn<0b110101, hasImmIdx, Op1Indirect,
            (outs), (ins GPR:$op1), (ins imm16:$imm),
            (ins idxn16:$idxn, idxc16:$idxc),
            "pushn", "$op1", "$imm", "(${idxn},${idxc})">;
}
} // hasSideEffects = 0, mayStore = 1

let hasSideEffects = 0, Constraints = "$dst = $op1" in {
defm NOT    : EBCALU<0b001010, "not">;
defm NEG    : EBCALU<0b001011, "neg">;
defm ADD    : EBCALU<0b001100, "add">;
defm SUB    : EBCALU<0b001101, "sub">;
defm MUL    : EBCALU<0b001110, "mul">;
defm MULU   : EBCALU<0b001111, "mulu">;
defm DIV    : EBCALU<0b010000, "div">;
defm DIVU   : EBCALU<0b010001, "divu">;
defm MOD    : EBCALU<0b010010, "mod">;
defm MODU   : EBCALU<0b010011, "modu">;
defm AND    : EBCALU<0b010100, "and">;
defm OR     : EBCALU<0b010101, "or">;
defm XOR    : EBCALU<0b010110, "xor">;
defm SHL    : EBCALU<0b010111, "shl">;
defm SHR    : EBCALU<0b011000, "shr">;
defm ASHR   : EBCALU<0b011001, "ashr">;

defm EXTNDB : EBCALU<0b011010, "extndb">;
defm EXTNDW : EBCALU<0b011011, "extndw">;
defm EXTNDD : EBCALU<0b011100, "extndd">;
} // hasSideEffects = 0, Constraints = "$dst = $op1"

defm CMPeq    : EBCCMP<0b000101, "eq">;
defm CMPlte   : EBCCMP<0b000110, "lte">;
defm CMPgte   : EBCCMP<0b000111, "gte">;
defm CMPulte  : EBCCMP<0b001000, "ulte">;
defm CMPugte  : EBCCMP<0b001001, "ugte">;

defm CMPIeq   : EBCCMPI<0b101101, "eq">;
defm CMPIlte  : EBCCMPI<0b101110, "lte">;
defm CMPIgte  : EBCCMPI<0b101111, "gte">;
defm CMPIulte : EBCCMPI<0b110000, "ulte">;
defm CMPIugte : EBCCMPI<0b110001, "ugte">;

foreach idxlen = [0b01, 0b10, 0b11] in {
  foreach movlen = !if(!eq(idxlen, 0b11), [0b11], [0b00, 0b01, 0b10, 0b11]) in
  defm MOV    : EBCMOV<0b011001, idxlen, movlen>;
}

foreach immlen = [0b01, 0b10, 0b11] in {
  foreach movlen = [0b00, 0b01, 0b10, 0b11] in {
    foreach Op1Indirect = [0b0, 0b1] in {
      foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in {
      def "MOVI"
        # !cond(!eq(movlen, 0b00) : "b", !eq(movlen, 0b01) : "w",
                !eq(movlen, 0b10) : "d", !eq(movlen, 0b11) : "q")
        # !cond(!eq(immlen, 0b01) : "w", !eq(immlen, 0b10) : "d",
                !eq(immlen, 0b11) : "q")
        # !if(Op1Indirect, "Op1I", "Op1D")
        # !if(hasOp1Idx, "Idx", "")
           : EBCMOVIBase<0b110111, immlen, movlen, hasOp1Idx, Op1Indirect,
                  (outs GPR:$op1), (ins),
                  (ins idxn16:$idxn, idxc16:$idxc),
                  !cond(!eq(immlen, 0b01) : (ins imm16:$imm),
                        !eq(immlen, 0b10) : (ins imm32:$imm),
                        !eq(immlen, 0b11) : (ins imm64:$imm)),
                  "$op1", "$imm", "(${idxn},${idxc})">;
      }
    }
  }
}

foreach immlen = [0b01, 0b10, 0b11] in {
  foreach Op1Indirect = [0b0, 0b1] in {
    foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in {
    def "MOVREL"
      # !cond(!eq(immlen, 0b01) : "w", !eq(immlen, 0b10) : "d",
              !eq(immlen, 0b11) : "q")
      # !if(Op1Indirect, "Op1I", "Op1D")
      # !if(hasOp1Idx, "Idx", "")
        : EBCMOVRELBase<0b111001, immlen, hasOp1Idx, Op1Indirect,
                  (outs GPR:$op1), (ins),
                  (ins idxn16:$idxn, idxc16:$idxc),
                  !cond(!eq(immlen, 0b01) : (ins imm16:$imm),
                        !eq(immlen, 0b10) : (ins imm32:$imm),
                        !eq(immlen, 0b11) : (ins imm64:$imm)),
                  "$op1", "$imm", "(${idxn},${idxc})">;
    }
  }
}

foreach idxlen = [0b01, 0b10] in {
  foreach Op1Indirect = [0b0, 0b1] in {
    foreach Op2Indirect = [0b0, 0b1] in {
      foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in {
        foreach hasOp2Idx = [0b0, 0b1] in
        def "MOVn"
          # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d")
          # !if(Op1Indirect, "Op1I", "Op1D")
          # !if(hasOp1Idx, "Idx", "")
          # !if(Op2Indirect, "Op2I", "Op2D")
          # !if(hasOp2Idx, "Idx", "")
            : EBCMOVnBase<!cond(!eq(idxlen, 0b01) : 0b110010,
                                !eq(idxlen, 0b10) : 0b110011),
            idxlen, hasOp1Idx, hasOp2Idx, Op1Indirect, Op2Indirect,
            (outs GPR:$op1), (ins GPR:$op2),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op1idxn, idxc16:$op1idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op1idxn, idxc32:$op1idxc)),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op2idxn, idxc16:$op2idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op2idxn, idxc32:$op2idxc)),
            "$op1", "$op2",  
            "(${op1idxn},${op1idxc})", "(${op2idxn},${op2idxc})">;
      }
    }
  }
}

foreach idxlen = [0b01, 0b10] in {
  foreach Op1Indirect = [0b0, 0b1] in {
    foreach Op2Indirect = [0b0, 0b1] in {
      foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in {
        foreach hasOp2Idx = [0b0, 0b1] in
        def "MOVsn"
          # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d")
          # !if(Op1Indirect, "Op1I", "Op1D")
          # !if(hasOp1Idx, "Idx", "")
          # !if(Op2Indirect, "Op2I", "Op2D")
          # !if(hasOp2Idx, !if(Op2Indirect, "Idx", "Imm"), "")
            : EBCMOVsnBase<!cond(!eq(idxlen, 0b01) : 0b100101,
                                 !eq(idxlen, 0b10) : 0b100110),
            idxlen, hasOp1Idx, hasOp2Idx, Op1Indirect, Op2Indirect,
            (outs GPR:$op1), (ins GPR:$op2),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op1idxn, idxc16:$op1idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op1idxn, idxc32:$op1idxc)),
            !cond(!eq(idxlen, 0b01) : (ins idxn16:$op2idxn, idxc16:$op2idxc),
                  !eq(idxlen, 0b10) : (ins idxn32:$op2idxn, idxc32:$op2idxc)),
            !cond(!eq(idxlen, 0b01) : (ins imm16:$op2imm),
                  !eq(idxlen, 0b10) : (ins imm32:$op2imm)),
            "$op1", "$op2",  
            "(${op1idxn},${op1idxc})", "(${op2idxn},${op2idxc})", "$op2imm">;
      }
    }
  }
}

foreach idxlen = [0b01, 0b10, 0b11] in {
  foreach Op1Indirect = [0b0, 0b1] in {
    foreach hasOp1Idx = !if(Op1Indirect, [0b0, 0b1], [0b0]) in
    def "MOVIn"
      # !cond(!eq(idxlen, 0b01) : "w", !eq(idxlen, 0b10) : "d",
              !eq(idxlen, 0b11) : "q")
      # !if(Op1Indirect, "Op1I", "Op1D")
      # !if(hasOp1Idx, "Idx", "")
        : EBCMOVInBase<0b111000, idxlen, hasOp1Idx, Op1Indirect,
        (outs GPR:$op1), (ins), (ins idxn16:$op1idxn, idxc16:$op1idxc),
        !cond(!eq(idxlen, 0b01) : (ins idxn16:$op2idxn, idxc16:$op2idxc),
              !eq(idxlen, 0b10) : (ins idxn32:$op2idxn, idxc32:$op2idxc),
              !eq(idxlen, 0b11) : (ins idxn64:$op2idxn, idxc64:$op2idxc)),
        "$op1", "(${op1idxn},${op1idxc})", "(${op2idxn},${op2idxc})">;
  }
}
